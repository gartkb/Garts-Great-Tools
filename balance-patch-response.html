<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Patch Response</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            text-align: center;
            pointer-events: none;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #ff4444;
        }

        #score-board {
            font-size: 32px;
            font-weight: bold;
            margin-top: 10px;
        }

        canvas {
            background-color: #333;
            border-bottom: 5px solid #1a1a1a;
            cursor: crosshair;
            display: block;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            color: #888;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>BALANCE PATCH RESPONSE</h1>
        <div id="score-board">Disapproval Score: 0</div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="instructions">
        Click anywhere to throw<br>
        (Performance optimized)
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-board');

        // Resize canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            logo.y = 100;
        });

        // --- Assets & Offscreen Buffer ---
        const logoImg = new Image();
        logoImg.crossOrigin = "Anonymous"; // Helps with canvas manipulation
        logoImg.src = "https://upload.wikimedia.org/wikipedia/fr/7/7f/ArenaNet_Logo.jpg";

        // Create an offscreen canvas to hold the logo + splats
        // This acts as a single image we update, rather than redrawing thousands of items
        const bufferCanvas = document.createElement('canvas');
        const bufferCtx = bufferCanvas.getContext('2d');

        // --- AUDIO SYSTEM (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let audioEnabled = false;
        
        function enableAudio() {
            if (!audioEnabled) {
                audioCtx.resume().then(() => audioEnabled = true);
            }
        }

        function playSplat() {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const t = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 0.2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1; 

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + 0.2); 

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }

        // --- Game Variables ---
        let score = 0;
        const projectiles = [];
        
        const logo = {
            x: canvas.width / 2 - 100,
            y: 80,
            width: 200,
            height: 100,
            speed: 2,    
            direction: 1
        };

        // --- Initialize Buffer ---
        logoImg.onload = () => {
            const aspect = logoImg.width / logoImg.height;
            logo.width = 200;
            logo.height = 200 / aspect;

            // Size the buffer to match the logo exactly
            bufferCanvas.width = logo.width;
            bufferCanvas.height = logo.height;

            // Draw the clean logo onto the buffer
            bufferCtx.drawImage(logoImg, 0, 0, logo.width, logo.height);
        };

        // --- Input Handling ---
        canvas.addEventListener('mousedown', (e) => {
            enableAudio(); 
            spawnProjectile(e.clientX, e.clientY);
        });

        function spawnProjectile(targetX, targetY) {
            const startX = canvas.width / 2;
            const startY = canvas.height;
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const speed = 12;

            projectiles.push({
                x: startX,
                y: startY,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                rotation: 0,
                rotSpeed: (Math.random() - 0.5) * 0.5
            });
        }

        // --- Game Loop ---
        function update() {
            // Move Logo
            logo.x += logo.speed * logo.direction;

            if (logo.x + logo.width > canvas.width) {
                logo.direction = -1;
            } else if (logo.x < 0) {
                logo.direction = 1;
            }

            // Move Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotSpeed;

                // Check Collision
                if (
                    p.x > logo.x &&
                    p.x < logo.x + logo.width &&
                    p.y > logo.y &&
                    p.y < logo.y + logo.height
                ) {
                    // HIT!
                    score++;
                    scoreEl.innerText = "Disapproval Score: " + score;
                    playSplat();

                    // BAKE THE SPLAT:
                    // Instead of saving coordinates, we draw directly onto the offscreen buffer
                    // Calculate relative position
                    const relX = p.x - logo.x;
                    const relY = p.y - logo.y;

                    bufferCtx.save();
                    bufferCtx.translate(relX, relY);
                    bufferCtx.rotate(p.rotation);
                    bufferCtx.font = "30px Arial";
                    bufferCtx.textAlign = "center";
                    bufferCtx.textBaseline = "middle";
                    bufferCtx.fillText("ðŸ’©", 0, 0);
                    bufferCtx.restore();

                    // Remove projectile
                    projectiles.splice(i, 1);
                    continue;
                }

                // Cleanup off-screen
                if (p.y < -50 || p.x < -50 || p.x > canvas.width + 50) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Logo (We draw the BUFFER, which contains the logo + all previous splats)
            // This is the performance fix: we only draw 1 image, not 1000 items.
            if (logoImg.complete) {
                ctx.drawImage(bufferCanvas, logo.x, logo.y);
            }

            // Draw Active Projectiles (Flying poos still need to be individual)
            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (let p of projectiles) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.fillText("ðŸ’©", 0, 0);
                ctx.restore();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        
        loop();

    </script>
</body>
</html>